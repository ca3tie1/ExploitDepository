#!/usr/bin/env python

"""
@Author: Castiel
@Email:  ca3tie1@gmail.com
@Blog:   https://ca3tie1.github.io
@Git:    https://github.com/ca3tie1
@Wechat: Ca5tie1
@Date:   2022/2/24 15:56
"""
import base64
import html
import json
import queue
import socket
import codecs
import asyncio
import ipaddress
import urllib.parse
from rich import box
from rich.live import Live
from scapy.all import *
from scapy.layers.inet import *
from rich.panel import Panel
from rich.table import Table
from rich.console import Console
from functools import partial
from ExpDepos.libs.core import Request
from Superscan import generate_table
from ServiceDetection import ServiceScan
from ExpDepos.libs.core.Response import Response
from ExpDepos.libs.core.common.Enums import FINGERPRINT
from ExpDepos.libs.core.common.Console import formatString
from ExpDepos.libs.core.base.Fingerprint import availableFilters
from PortLists import nmap_top_10000, default_ports, extend_ports
from ExpDepos.libs.core.common.Common import console, timeit, env
from ExpDepos.libs.core.base.ExceptionBase import ExploitValidationException
from rich.progress import Progress, SpinnerColumn, BarColumn, TextColumn, TimeRemainingColumn


def range_number(start, end) -> list:
    """
    IP范围或是端口范围生成

    @param start: 范围起始值
    @type start: int
    @param end: 范围结束值
    @type end: int
    @return: start和end之间所有数值列表(含start和end)
    @rtype: list
    """
    if not start or not end:
        ExploitValidationException("数字号段参数错误，请设置起始和结束值!")
    if not isinstance(start, int) or not isinstance(end, int):
        raise ExploitValidationException("数字号段起始和结束值必须为整数!")
    return list(range(int(start), int(end) + 1))


def start_loop(loop):
    """
    开启事件循环 用于线程中设置新的事件循环

    @param loop: 事件循环对象
    @return:
    """
    asyncio.set_event_loop(loop)
    loop.run_forever()


def stop_loop(loop):
    """
    停止事件循环

    @param loop: 事件循环对象
    @return:
    """
    loop.stop()


def update_table(table, work_out, null=""):
    """
    更新端口扫描结果表格内容

    @param table: 端口扫描结果表格(rich.Table 对象)
    @param work_out: 更新内容值
    @param null: 无
    @return:
    """
    if work_out is None:
        return
    cls_size = len(table.columns)
    cls_list = []
    for ip, ports in work_out.items():
        if not ports:
            return
        for port in ports:
            cls_list.append(ip)
            if isinstance(port, tuple):  # 如果端口为tuple类型 则为端口加端口服务、版本、指纹识别结果等信息
                cls_list.extend([str(value) if value else '' for value in list(port)])
            else:
                cls_list.append(str(port))
            # 使用null参数值填充没有值的列
            if len(cls_list) < cls_size:
                for num in range(cls_size - len(cls_list)):
                    cls_list.append(null)
            table.add_row(*(tuple(cls_list)))
            cls_list = []


def send_package(host: str, sock: socket.socket, package: bytes, port: int = 0):
    """
    发送数据包并接受返回数据

    @param host: 目标ip
    @type host: str
    @param sock: socket 对象
    @type sock: socket
    @param package: 数据包
    @type package: bytes
    @param port: 端口号
    @type port: int
    @return:
    @rtype:
    """
    try:
        sock.sendto(package, (socket.gethostbyname(host), port))
        rev, address = sock.recvfrom(1024)
        return rev, address
    except Exception as e:
        return None, None


async def exec_sync_fun(fun, args):
    """
    实现在异步函数中调用阻塞的同步函数时为可等待调用

    @param fun: 要执行的同步函数
    @param args: 同步函数的参数
    @return:
    """
    loop = None
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError as e:
        if "There is no current event loop in thread" in str(e):
            loop = asyncio.new_event_loop()
    return await loop.run_in_executor(None, fun, *args)


def fingerprint2list(nmap_fingerprint, progress: Progress = None) -> list:
    """
    转化服务识别结果为Table rows的列表数据

    @param nmap_fingerprint: 指纹识别结果
    @type nmap_fingerprint: dict
    @param progress: 进度条对象
    @type progress: Progress
    @return: Table rows的列表数据
    @rtype: list
    """
    service = "Unknown"
    server_version = None
    web_title = status_code = fp_matches = exploit = ''
    if nmap_fingerprint:
        try:
            if "match" in nmap_fingerprint:
                service = nmap_fingerprint["match"]["versioninfo"]["vendorproductname"][0]
                version = nmap_fingerprint["match"]["versioninfo"]["version"]
                if bool(nmap_fingerprint["match"]["versioninfo"]["info"]) and not version:
                    service += f"({nmap_fingerprint['match']['versioninfo']['info'][0]})"
                if version:
                    server_version = version[0] if isinstance(version, list) else version
            if "web_matches" in nmap_fingerprint:
                web_result = nmap_fingerprint["web_matches"]
                if web_result:
                    response, fp_matches, exploit = web_result
                    if response:
                        web_title = match_web_title(response)
                        status_code = response.status_code
                        if service == "Unknown" or not service:
                            service = "Http"
        except Exception as e:
            progress.print(f"{repr(e)}: {nmap_fingerprint}")
    return [service, server_version, web_title, status_code, fp_matches, exploit]


def format_fp_matches(matches, mini_percent=30):
    """
    格式化匹配的指纹信息 只显示指纹名称

    @param matches: 匹配的指纹信息
    @type matches: dict
    @param mini_percent: 指纹匹配度最小限制
    @type mini_percent: int
    @return:
    @rtype:
    """
    if not matches:
        return ''
    match_list = []
    sorted_matches = sorted(matches, key=lambda k: k["percent"], reverse=True)
    for match in sorted_matches:
        if match["percent"] > mini_percent:
            match_list.append(f"{match['fp_name']} ([bold magenta]{match['percent']}%[/bold magenta])")
    return match_list


def is_close_with_exception(e, progress):
    """
    根据连接异常信息判断端口是否关闭

    @param e: 异常类
    @type e: Exception
    @param progress: 进度条对象
    @type progress: Progress
    @return: 端口是否关闭
    @rtype: boolean
    """
    if "Too many open files" in repr(e):
        progress.print(formatString("Too many open files! "
                                    "当前线程数量过高, 请调整线程数量或使用 [green]ulimit -n[/green] 设置资源限制值.",
                                    level="WARNING", space=11, gap=6))
        return True
    if "ConnectionRefusedError" in repr(e) or "TimeoutError" in repr(e) \
            or "Host is down" in repr(e) or "Connect call failed" in repr(e):
        return True


def is_http_match(result_set):
    """
    校验匹配结果是否为HTTP探针或者识别到http响应

    @param result_set: 匹配结果
    @type result_set: list
    @return:
    @rtype:
    """
    if not result_set:
        return False
    http_probes = ["GetRequest", "HTTPOptions", "RTSPRequest"]
    for match in result_set:
        if ("probe" in match and match["probe"]["probename"] in http_probes) or match["match_http"]:
            return True


def is_exploit_match(fp_matches):
    """
    校验是否匹配了exploit模块指纹

    @param fp_matches: 匹配成功的指纹列表
    @type fp_matches: list
    @return:
    @rtype:
    """
    for match in fp_matches:
        if "regByExp" in match and match["regByExp"]:
            return match["regByExp"]
    return False


def format_exploit(exploit: str):
    if exploit == '':
        return ''
    if "." in exploit:
        return f"[bold red]{exploit[exploit.rindex('.') + 1:]}[/bold red]"
    return exploit


def is_http_port(port_info):
    """
    检查端口是否为WEB服务端口

    @param port_info: 端口信息
    @type port_info: tuple
    @return:
    @rtype:
    """
    port = port_info[0]
    return str(port) in default_ports.split(",")


def get_domain(host):
    """
    解析host中的域名值

    :param host: host
    :type host: str
    :return:
    :rtype:
    """
    matches = re.match(r"[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z][-a-zA-Z]{0,62})+\.?", host)
    if matches:
        return matches.group(0)
    return None


def match_web_title(response):
    """
    正则匹配WEB页面标题

    @param response: response对象
    @type response:
    @return:
    @rtype:
    """
    regexp = "<title>([\\s\\S]+)</title>"
    pattern_compiled = re.compile(regexp, re.IGNORECASE)
    match = re.search(pattern_compiled, response.text)
    if match:
        return html.unescape(match.group(1).replace('&nbsp;', ' '))
    return ''


def is_https_port(port):
    """
    校验端口是否为https

    @param port:
    @type port:
    @return:
    @rtype:
    """
    https_ports = [443, 853, 8443, 8843, 4433, 4740, 5349, 5684, 5868, 6514, 6636, 8232, 10161, 10162, 12346, 12446,
                   12546, 12646, 12746, 12846, 12946, 13046]
    return port in https_ports


def count_identify(work_out_list):
    count = 0
    for host, ports in work_out_list.items():
        count += len(ports)
    return count


def build_endpoint(host, port, proto, payload, conn_only=False):
    proxy_endpoint = f"sock://{host}:{port}/{proto}"
    if payload:
        data = base64.b64encode(payload).decode()
        proxy_endpoint += f"?data={data}"
    if conn_only:
        proxy_endpoint += f"?conn_only=true"
    return proxy_endpoint


def segment2text(segments):
    """
    转换rich到segment对象为text字符串

    @param segments: segment对象
    @type segments: Iterable[Segment]
    @return:
    @rtype:
    """
    if not segments:
        return ''
    text = "".join(
        segment.text
        for segment in segments
        if not segment.is_control
    )
    return text


class SuperPort:
    def __init__(self, superscan):
        self.superscan = superscan
        self.request = self.superscan.request
        self.timeout = 5  # socket time out
        self.thread_number = self.superscan.get_option("thread")  # 默认线程数
        self.ulimit = 4096
        self.coroutine_number = env.CliOptions.thread  # 端口扫描时的协程并发量
        self.exitFlag = False  # 线程退出标识
        self.subExitFlag = False
        self.queueLock = threading.Lock()
        self.workQueue = queue.Queue()  # 多线程端口扫描任务等待队列
        self.workIdentifyQueue = queue.Queue()  # 多线程服务识别任务等待队列
        self.workPortQueue = queue.Queue()  # 端口扫描结果临时存放队列 用于实时显示端口扫描结果
        self.workOutPortList = {}  # 存放端口扫描完成的主机 用于统计端口扫描完成量 为服务识别进度条更新总数
        self.workOutQueue = queue.Queue()  # 多线程服务识别任务完成队列
        self.workOutList = []  # 存放所有已完成的任务 用于确定任务是否全部完成
        self.result = {}  # 扫描结果
        # 初始化选项值
        self.noPing = self.superscan.get_option("noping")
        self.usescf = env.CliOptions.useScf or self.superscan.scf_test
        self.noProbe = self.superscan.get_option("noprobe")
        self.noweb = self.superscan.get_option("noweb")
        self.nofp = self.superscan.get_option("nofp")
        self.nosrv = self.superscan.get_option("nosrv")
        self.hostfile = self.superscan.get_option("hostfile")
        self.fpmode = self.superscan.get_option("fpmode")
        # 初始化端口列表
        self.ports = []
        self.init_ports()
        # 初始化主机列表
        self.hosts = []
        self.init_hosts()
        # 端口服务探针
        self.serviceProbe = None
        self.excludeProbe = True
        self.web_mini_percent = 30  # web指纹匹配度最小限制
        self.fingerprint_filter = self.init_fp_filters()  # 初始化指纹过滤器

    def init_fp_filters(self):
        filters = {}
        if self.superscan.get_option("fptype"):
            filters.update({"type": self.superscan.get_option("fptype").split(",")})
        else:
            filters.update({"type": [FINGERPRINT.FP_TYPE.WEBAPP,
                                     FINGERPRINT.FP_TYPE.MIDDLEWARE,
                                     FINGERPRINT.FP_TYPE.DEVICE,
                                     FINGERPRINT.FP_TYPE.VULNERABILITY]})
        if self.superscan.get_option("fpplat"):
            filters.update({"platform": self.superscan.get_option("fpplat").split(",")})
        if self.superscan.get_option("fpmidd"):
            filters.update({"middleware": self.superscan.get_option("fpmidd").split(",")})
        if self.superscan.get_option("fplang"):
            filters.update({"language": self.superscan.get_option("fplang").split(",")})
        availableFilters(filters)
        return filters

    def init_ports(self):
        """
        初始化端口列表

        @return:
        @rtype:
        """
        if self.superscan.get_option("ports"):
            ports = self.superscan.get_option("ports")
            if ports == "web":
                self.ports = self.parse_ports(default_ports)
            elif ports == "top":
                self.ports = self.parse_ports(default_ports + "," + extend_ports + "," + nmap_top_10000)
            else:
                self.ports = self.parse_ports(self.superscan.get_option("ports"))
        else:
            self.ports = self.parse_ports(default_ports + "," + extend_ports)

    @staticmethod
    def _get_hostname(host_str):
        """
        获取主机名

        :param host_str: 主机字符串
        :type host_str: str
        :return:
        :rtype:
        """
        host = None
        try:
            url = urllib.parse.urlparse(host_str)
            if url.hostname:
                host = url.hostname
            else:
                # host_str为IP地址时候无hostname值 只有path值
                host = url.path
        except Exception as e:
            pass
        return host

    def init_hosts(self):
        """
        初始化主机列表

        @return:
        @rtype:
        """
        hosts = []
        host = self.superscan.get_option("host")
        if not host and not self.hostfile:
            raise ExploitValidationException("请使用--host选项或者--hostfile指定目标主机")
        hosts.extend(host.split(","))

        # 从文件中读取主机信息
        if self.hostfile:
            if not os.path.exists(self.hostfile):
                raise ExploitValidationException(f"文件{self.hostfile}不存在!")
            with open(self.hostfile) as hostfile:
                lines = hostfile.readlines()
                for line in lines:
                    line = line.replace("\n", "")
                    hosts.extend(line.split(","))
        # 去重
        hosts = list(set(hosts))
        # 解析主机信息
        self.hosts = self.parse_hosts(hosts)

    def parse_ports(self, ports: str) -> list:
        """
        解析用户自定义端口列表

        @param ports: 用户自定义的端口
        @type ports: str
        @return: 端口列表
        @rtype: list
        """
        return_ports = []
        ports = ports.split(",")
        for port in ports:
            if "-" in port:  # 生成端口范围
                dash = port.split("-")
                if dash[0] == '' or dash[1] == '':
                    raise ExploitValidationException("端口号范围格式错误, 请使用 '-' 间隔起始和结束值!")
                start = int(dash[0])
                end = int(dash[1])
                if start < 1 or end > 65535:
                    raise ExploitValidationException(f"端口号范围[bold green] {port} [/bold green]错误，"
                                                     f"必须为[bold green] 1-65535 [/bold green] 之间的整数!")
                range_port = range_number(start, end)
                return_ports.extend(range_port)
                continue
            if not re.match("[\\d]+", port):
                raise ExploitValidationException(f"端口号[bold green] {port} [/bold green]错误，"
                                                 f"必须为[bold green] 1-65535 [/bold green] 之间的整数!")
            return_ports.append(int(port))
        return list(set(return_ports))

    def parse_hosts(self, hosts: list) -> list:
        """
        解析主机信息

        @param hosts: 主机信息列表
        @type hosts: list
        @return: 解析后的所有主机列表
        @rtype: list
        """
        host_list = []
        for host in hosts:
            host = host.strip()
            host = self._get_hostname(host)
            if not host:
                continue
            try:
                # 加正则匹配确保含 "-" 符号的为IP地址 而非域名
                if "-" in host\
                        and re.match(r"((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}",
                                     host):
                    dash = host[host.rindex(".") + 1:]
                    prefix = host[:host.rindex(".") + 1]
                    ipaddr = ipaddress.ip_network(prefix + "0", strict=False)
                    if self.usescf and ipaddr.is_private:
                        console.warning(f"Host {host} 为私有网络, 将无法使用云函数扫描, 已自动关闭云函数!")
                        self.usescf = False
                    dash_s = dash.split("-")
                    if dash_s[0] == '' or dash_s[1] == '':
                        raise ExploitValidationException("IP范围格式错误, 请使用 '-' 间隔起始和结束值!")
                    start = int(dash_s[0])
                    end = int(dash_s[1])
                    if start < 1 or end > 255:
                        raise ExploitValidationException(f"IP范围[bold green] {dash} [/bold green]错误，"
                                                         f"必须为[bold green] 1-255 [/bold green] 之间的整数!")
                    range_hosts = range_number(start, end)
                    for h in range_hosts:
                        host_list.extend(list(ipaddress.ip_network(prefix + str(h))))
                    continue
                domain = get_domain(host)
                if domain:
                    host = socket.gethostbyname(domain)
                ipaddr = ipaddress.ip_network(host, strict=False)
                if self.usescf and ipaddr.is_private:
                    console.warning(f"Host {host} 为私有网络, 将无法使用云函数扫描, 已自动关闭云函数!")
                    self.usescf = False
                host_list.extend(list(ipaddr))
            except ipaddress.AddressValueError as e:
                raise ExploitValidationException(e.args[0])
            except ipaddress.NetmaskValueError as e:
                raise ExploitValidationException(e.args[0])
            except ValueError as e:
                raise ExploitValidationException(e.args[0])
        return host_list

    @timeit
    def start(self) -> dict:
        """
        扫描入口

        @return:
        @rtype:
        """
        if not sys.platform.startswith('win'):
            self.check_ulimit()
        else:
            console.warning("当前模块运行在Windows中, 为达到最佳性能, 建议在MaxOS或者Kali上运行本模块!")
        if not self.noProbe:
            with console.rConsole.status(formatString("正在初始化服务探针..."), spinner="point"):
                instanced = False
                while self.serviceProbe is None:
                    if not instanced:
                        try:
                            self.init_probes()
                        except Exception as e:
                            self.noProbe = True
                            console.error(f"服务探针初始化失败, 已自动禁用自动识别端口服务! {repr(e)}")
        # 初始化实时结果显示表格
        progress_vars = self.init_progress()
        progress, alive_task, main_task, identify_task, overall_progress, overall_task, process_grid, \
        open_port_table, result_table = progress_vars

        # 默认使用ping扫描 需要验证存活主机
        ping_loop = self.fill_queue(progress, alive_task)

        if not self.hosts:
            raise ExploitValidationException("未找到存活主机, 请使用noping选项再试!")

        # 队列填充完成后再创建并启动线程，防止与填充过程冲突
        threads, identify_threads = self.start_threads(progress)

        # 等待队列清空及任务完成
        with Live(process_grid, refresh_per_second=3, vertical_overflow="visible"):
            while not overall_progress.finished or any(
                    (not self.workPortQueue.empty(), not self.workOutQueue.empty(), not self.workQueue.empty())):
                if not self.noPing:  # 如果是ping扫描 更新端口扫描进度条总量为实时的self.hosts总数
                    progress.update(main_task, total=len(self.hosts) * len(self.ports))

                if self.workPortQueue.qsize() > 0:  # 如果端口扫描结果临时队列中有数据 则实时显示开放端口
                    open_port = self.workPortQueue.get()
                    update_table(open_port_table, open_port, null="[green]Open")
                    self.save_output(open_port_table, result_table)
                    if self.noProbe:  # 修复仅端口扫描时候没有最终结果返回的Bug
                        self.result.update(open_port)

                for task in progress.tasks:  # 检查端口扫描进度条是否完成 并更新服务识别进度条总量
                    if "端口扫描" in task.description and task.finished and not self.noProbe:
                        # progress.print(f"port scan finished len of workoutportlist: {len(self.workOutPortList)}")
                        progress.update(identify_task, total=count_identify(self.workOutPortList))

                if self.workOutQueue.qsize() > 0:  # 如果任务完成队列有数据 则取出一个并更新服务识别进度条
                    result = self.workOutQueue.get()
                    self.result.update(result)
                    update_table(result_table, result, null="")
                    self.save_output(open_port_table, result_table)

                # 更新整体进度条
                total = sum(task.total for task in progress.tasks)
                completed = sum(task.completed for task in progress.tasks)
                overall_progress.update(overall_task, total=total, completed=completed)
                time.sleep(0.5)

        if not self.noPing:
            # 停止存活主机探测线程的事件循环
            ping_loop.call_soon_threadsafe(partial(stop_loop, ping_loop))

        # 设置线程退出标识
        self.exitFlag = True

        # 等待线程同步
        for t in threads:
            t.join()
        if identify_threads:
            for it in identify_threads:
                it.join()

        return self.result

    def save_output(self, open_port_table, result_table):
        """
        保存结果至文件

        @param open_port_table: 端口开放结果集
        @type open_port_table: Table
        @param result_table: 扫描结果集
        @type result_table: Table
        @return:
        @rtype:
        """
        if self.superscan.get_option("output"):
            out_file = self.superscan.get_option("output")
            if out_file == "Dirscan_output.log":
                out_file = "Portscan_output.log"
        else:
            out_file = "Portscan_" + self.superscan.get_option("host").replace("/", "_").replace(",", "-") + ".log"
        out_put_path = self.superscan.output_path + out_file
        consoles = Console(record=True)
        open_port_segments = consoles.render(open_port_table)
        result_table_segments = consoles.render(result_table)
        with open(out_put_path, mode="w", encoding="UTF-8") as out_put:
            out_put.write(segment2text(open_port_segments))
            out_put.write(segment2text(result_table_segments))

    def check_ulimit(self):
        """
        检查ulimit值

        @return:
        @rtype:
        """
        try:
            complete_process = subprocess.run(["ulimit", "-n"], capture_output=True)
            if complete_process.stdout:
                current = int(complete_process.stdout)
                if current < self.ulimit:
                    console.warning(f"当前ulimit值 {current} 过小, 建议使用 [bold yellow]ulimit -n[/bold yellow] 设置为大于"
                                    f" {self.ulimit} 的值!")

        except Exception as e:
            console.warning(f"尝试设置ulimit值出错: {repr(e)}")

    def init_probes(self):
        """
        初始化服务指纹探针

        @return:
        @rtype:
        """
        try:
            probe_service = ServiceScan(filename=self.superscan.dic_path + "nmap-service-probes")
            self.serviceProbe = probe_service
        except Exception as e:
            raise e

    def init_progress(self):
        """
        初始化实时显示及进度条对象

        @return: 初始化后对象引用变量列表
        """
        # 整体扫描进程网格
        process_grid = Table.grid()
        # 开放端口实时显示表格，每扫描到一个开放端口立即更新显示
        open_port_table = generate_table(["HOST", "PORT", "STATUS"], box=box.SIMPLE_HEAD, width=60)
        # 完整扫描结果实时显示表格，每个主机端口扫描及服务、指纹识别完成后更新显示
        result_table = generate_table(["HOST", "Open Port", "Service", "Service Version",
                                       "Web Title", "Status_Code", "FPMatch", "Exploit"])
        # 线程进度条对象
        progress = Progress("{task.description}",
                            SpinnerColumn(),
                            BarColumn(),
                            TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                            TimeRemainingColumn())
        # 存活主机探测线程进度条
        alive_task = progress.add_task("[green]存活探测:", total=len(self.hosts))
        # 将端口显示表格和扫描结果表格添加到整体扫描网格中
        process_grid.add_row(Panel.fit(open_port_table, box=box.SIMPLE_HEAD, title="",
                                       border_style="red", padding=(0, 0, 0, 10)))
        if not self.noProbe:
            process_grid.add_row(Panel.fit(result_table, box=box.SIMPLE_HEAD, title="Scanning Result",
                                           border_style="red", padding=(0, 0, 0, 10)))

        # 添加端口扫描进度条
        main_task = progress.add_task(f"[cyan]端口扫描:[/cyan]",
                                      total=len(self.hosts) * len(self.ports))
        # 添加服务识别进度条
        identify_task = progress.add_task("[magenta]服务识别:", total=len(self.hosts))
        if self.noProbe:
            progress.update(identify_task, completed=len(self.hosts))

        # 添加整体进度条
        overall_progress = Progress("{task.description}",
                                    SpinnerColumn(),
                                    BarColumn(),
                                    TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                                    TimeRemainingColumn())
        total = sum(int(task.total) for task in progress.tasks)
        overall_task = overall_progress.add_task("[bold yellow]扫描进度:", total=total)

        # 将整体进度条及线程进度条添加到一个网格中
        progress_table = Table.grid()
        progress_table.add_row(
            Panel.fit(overall_progress, title="[b]Overall Progress", border_style="cyan", padding=(1, 2)),
            Panel.fit(progress, title="[b]Process Progress", border_style="red", padding=(0, 2)))
        # 再将该以上网格添加到整体扫描网格中
        process_grid.add_row(Panel.fit(progress_table, box=box.SIMPLE_HEAD, padding=(0, 0, 0, 10)))

        return (
            progress, alive_task, main_task, identify_task, overall_progress, overall_task, process_grid,
            open_port_table, result_table)

    def fill_queue(self, progress, alive_task):
        """
        填充扫描队列

        @param progress: 进度条对象
        @param alive_task: 存活主机验证进度条id
        @return: 返回存活主机验证线程的事件循环对象(如果需要验证存活主机 否则为None)
        """
        ping_loop = None
        # 默认使用ping扫描 需要验证存活主机
        if not self.noPing:
            ping_loop = self.start_chk_alive_hosts(progress)  # 扫描队列在主机存活验证线程中填充
        else:
            progress.update(alive_task, advance=len(self.hosts), description="[green]存活探测:")
            # 在线程启动前先使用hosts填充队列，防止线程读取与填充冲突
            for host in self.hosts:
                self.workQueue.put(str(host))
        return ping_loop

    def start_threads(self, progress):
        """
        启动所有扫描线程

        @param progress: 进度条对象
        @return: 已启动的端口扫描线程和服务识别线程列表
        """
        threads = self.start_portscan_threads(progress)
        if not self.noProbe:
            identify_threads = self.start_identify_threads(progress)
        else:
            identify_threads = []

        progress.print(formatString(f"已启动 {len(threads)} 个扫描线程"
                                    f"{', 1 个主机存活探测线程' if not self.noPing else ''}"
                                    f"{', ' + str(len(identify_threads)) + ' 个服务识别线程.' if not self.noProbe else '.'}",
                                    level="INFO", space=11, gap=9))
        return threads, identify_threads

    def start_portscan_threads(self, progress):
        """
        启动端口扫描线程

        @param progress: 进度条对象
        @return: 已启动的线程列表
        """
        threads = []
        thread_id = 1
        for tName in range(1, self.thread_number + 1):
            thread = SuperPort.MyThread(thread_id, "Thread-" + str(tName), self.workQueue, self.thread_scanner,
                                        progress)
            thread.start()
            threads.append(thread)
            thread_id += 1
        return threads

    def start_identify_threads(self, progress):
        """
        启动服务识别及指纹匹配线程

        @param progress: 进度条对象
        @return: 已启动的线程列表
        """
        # 启动服务识别线程(默认启动10个)
        identify_threads = []
        thread_id = 1
        for tName in range(1, self.thread_number + 1):
            thread = SuperPort.MyThread(thread_id, "Thread-" + str(tName), self.workIdentifyQueue, self.thread_identify,
                                        progress)
            thread.start()
            identify_threads.append(thread)
            thread_id += 1
        return identify_threads

    def thread_scanner(self, thread_name, work_queue: queue.Queue, progress):
        """
        多线程端口扫描入口

        @param thread_name: 线程名称
        @type thread_name: str
        @param work_queue: 扫描任务队列
        @type work_queue: Queue
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        while not self.exitFlag:
            self.queueLock.acquire()
            if not work_queue.empty():
                host = work_queue.get()
                self.queueLock.release()
                progress.print(formatString(f"线程 {thread_name} 正在扫描主机: {host}, 共 {len(self.ports)} 个端口.",
                                            level="INFO", space=11, gap=9))
                ports = self.ports_scanner(host, self.ports.copy(), progress)
                if not ports:
                    self.queueLock.acquire()
                    self.workOutList.append(host)  # 将没有端口开放的主机放入完成列表中, 有端口开放的需要等待服务识别完成再放入。
                    self.queueLock.release()
                    continue
                self.queueLock.acquire()
                self.workIdentifyQueue.put({host: ports})  # 每完成一个IP 将结果存入服务识别等待队列中 服务识别线程开始工作
                self.queueLock.release()
                progress.print(formatString(f"主机: {host} 端口扫描完成, 共发现 {len(ports)} 个端口开放!",
                                            level="INFO", space=11, gap=9))
            else:
                self.queueLock.release()

    def thread_identify(self, thread_name, work_queue: queue.Queue, progress):
        while not self.exitFlag:
            self.queueLock.acquire()
            if not work_queue.empty():
                host = work_queue.get()
                self.queueLock.release()
                # 服务识别逻辑
                result = self.servers_identify(host, progress)

                # 跟新队列
                self.queueLock.acquire()
                self.workOutList.append(host)  # 更新完成列表
                self.workOutQueue.put(result)
                self.queueLock.release()
            else:
                self.queueLock.release()

    def ports_scanner(self, host, ports, progress: Progress):
        """
        扫描主机端口

        @param host: 主机地址
        @param ports: 待扫描端口列表
        @param progress: 进度条对象
        @return: 开放端口列表
        """
        # 在当前线程中再启用协程并发扫描
        result = []
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        # 修复windows报Event loop is closed的问题
        py_ver = int(f"{sys.version_info.major}{sys.version_info.minor}")
        if py_ver > 37 and sys.platform.startswith('win'):
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        asyncio.set_event_loop(loop)
        loop.run_until_complete(self.async_ports_scanner(host, ports, progress, result))
        return result

    def shorted_ports(self, ports):
        """
        将待扫描端口按nmap top 10000优先级排序

        @param ports: 待扫描端口列表
        @return: 排序好的列表
        """
        shorted = []
        nmap_top_ports = self.parse_ports(nmap_top_10000)

        # 先将位于nmap top 10000中的端口弹出并放入shorted列表
        for nmap_port in nmap_top_ports:
            if nmap_port in ports:
                shorted.append(ports.pop(ports.index(nmap_port)))
        # 最后合并剩余的列表并返回
        shorted.extend(ports)
        return shorted

    async def async_ports_scanner(self, host, ports, progress: Progress, result):
        """
        协程并发端口扫描

        @param host: 主机地址
        @type host: str
        @param ports: 待扫端口列表
        @type ports: list
        @param progress: 进度条对象
        @type progress: Progress
        @param result: 扫描结果列表
        @type result: list
        @return: 开放端口列表
        @rtype: list
        """
        # 使用云函数扫描时候协程并发量由env.CliOptions.thread控制
        # sem = asyncio.Semaphore(env.CliOptions.thread if self.usescf else self.coroutine_number)
        coroutine_number = self.coroutine_number
        if len(ports) > coroutine_number:  # 如果待扫端口总量大于协程并发量才将端口按常用优先级排序 实现先扫描常用端口逻辑
            ports = self.shorted_ports(ports)  # 将端口按常用优先排序

        sem = asyncio.Semaphore(coroutine_number)

        async def aw_task(aw):
            async with sem:
                return await aw

        task_list = []
        for port in ports:
            is_open = self.chk_is_open(host, port, progress, result)
            if sys.version_info < (3, 7):
                task = asyncio.ensure_future(aw_task(is_open))
            else:
                task = asyncio.create_task(aw_task(is_open))
            task_list.append(task)
        return await asyncio.gather(*task_list)

    async def chk_is_open(self, host, port, progress: Progress, result):
        """
        扫描指定端口是否开放

        @param host: 主机地址
        @type host: str
        @param port: 端口号
        @type port: int
        @param progress: 进度条对象
        @type progress: Progress
        @param result: 扫描结果列表
        @type result: list
        @return: 开放端口列表
        @rtype: list
        """
        if self.usescf:
            scf_result = await self.open_connect_scf(host, port, progress)
            if scf_result and "connected" in scf_result and scf_result["connected"]:
                self.queueLock.acquire()
                self.workPortQueue.put({host: [port]})
                self.queueLock.release()
                result.append((port, scf_result["body"]))
        else:
            connected = await self.open_connect(host, port, progress)
            if connected:
                self.queueLock.acquire()
                self.workPortQueue.put({host: [port]})
                self.queueLock.release()
                # 尝试读取返回数据
                reader, writer = connected
                d_reader = reader.read(1024)
                try:
                    data = await asyncio.wait_for(d_reader, timeout=self.timeout)
                except Exception as e:
                    data = b''
                finally:
                    try:
                        writer.close()
                        await writer.wait_closed()
                    except Exception as e:
                        progress.print(formatString(repr(e), level="WARNING", space=11, gap=6))
                    data = b''
                # 将返回的二进制数据base64编码后放到结果列表中
                result.append((port, base64.b64encode(data).decode()))

        # 每扫描一个端口便更新一次端口扫描进度条
        for task in progress.tasks:
            if "端口扫描" in task.description:
                self.queueLock.acquire()
                progress.update(task.id, advance=1)
                # 更新端口扫描完成字典 用于统计端口扫描完成量 为服务识别进度条更新总数
                self.workOutPortList.update({host: result})
                self.queueLock.release()
            # 每扫描一个端口立即更新服务识别进度条总量 防止跟新不及时导致服务识别提早完成
            if "服务识别" in task.description and not self.noProbe:
                self.queueLock.acquire()
                progress.update(task.id, total=count_identify(self.workOutPortList))
                self.queueLock.release()
        return result

    async def open_connect(self, host, port, progress: Progress):
        """
        建立对应端口的连接

        @param host: 主机地址
        @type host: str
        @param port: 端口号
        @type port: int
        @param progress: 进度条对象
        @type progress: Progress
        @return: 是否连接成功
        @rtype: boolean
        """
        try:
            fut = asyncio.open_connection(host, port)
            is_connect_success = await asyncio.wait_for(fut, timeout=self.timeout)
            if is_connect_success:
                return is_connect_success
            else:
                return False
        except Exception as e:
            if is_close_with_exception(e, progress):
                return False
            progress.print(formatString(f"{repr(e)} in open_connect", level="WARNING", space=11, gap=6))
            return False

    async def open_connect_scf(self, host, port, progress: Progress, proto="TCP", send_data=b"", timout=5):
        conn_only = self.noProbe or self.nosrv  # 不进行服务探测则默认开启仅连接测试 无需获取返回数据 提高探测速度
        endpoint = build_endpoint(host, port, proto, send_data, conn_only)
        return await self.scf_request(endpoint, progress)

    def servers_identify(self, host: dict, progress: Progress):
        # 在当前线程中再为每个端口启动一个子线程
        sub_threads = []
        self.subExitFlag = False
        sub_work_queue = queue.Queue()
        flag_name = ''
        current_host = ''
        for ip, ports in host.items():
            # 在当前对象中设置两个标志性属性 用于标识任务是否已全部完成和存储结果
            flag_name = f"_sub_{ip}_"
            setattr(self, flag_name + 'exit_flag', False)
            setattr(self, flag_name + 'result_set', [])
            current_host = ip
            for port_info in ports:
                sub_work_queue.put({ip: port_info})  # 任务队列
        # 启动线程
        for tId in range(1, sub_work_queue.qsize() + 1):
            sub_thread = SuperPort.MyThread(tId, f"Sub-Thread({ip})-{str(tId)}",
                                            sub_work_queue,
                                            self.sub_thread_identify,
                                            progress, flag_name=flag_name)
            sub_thread.start()
            sub_threads.append(sub_thread)

        while not sub_work_queue.empty():  # 等待任务队列清空
            pass

        setattr(self, flag_name + 'exit_flag', True)  # 设置子线程退出标识

        for sub_thread in sub_threads:  # 线程同步
            sub_thread.join()

        result_set = getattr(self, flag_name + 'result_set')  # 获取识别结果
        return {current_host: result_set}

    def sub_thread_identify(self, thread_name, work_queue: queue.Queue, progress, **kwargs):
        flag_name = kwargs["flag_name"]
        while not getattr(self, flag_name + 'exit_flag'):
            self.queueLock.acquire()
            if not work_queue.empty():
                host = work_queue.get()
                self.queueLock.release()
                ip = list(host.keys())[0]
                port_info = list(host.values())[0]
                progress.print(formatString(f"子线程 {thread_name} 正在探测 {ip}:{port_info[0]} 对应服务!", level="INFO",
                                            space=11, gap=9))
                try:
                    result = self.probes_by_port(ip, port_info, progress)
                except Exception as e:
                    result = []
                    progress.print(formatString(repr(e), level="WARNING", space=11, gap=6))
                self.queueLock.acquire()
                # 将扫描结果存储到标志属性中
                result_set = getattr(self, flag_name + 'result_set')
                result_set.extend(result)
                setattr(self, flag_name + 'result_set', result_set)
                # self.workOutQueue.put({ip: result})     # 每完成一个端口的服务识别后更新队列用于实时显示
                self.queueLock.release()
                progress.print(formatString(f"主机 {ip}:{port_info[0]} 服务探测完成!", level="INFO",
                                            space=11, gap=9))
            else:
                self.queueLock.release()

    def probes_by_port(self, host, port_info, progress):
        """
        探测端口服务及版本

        @param host: 主机地址
        @type host: str
        @param port_info: 含端口号或者端口返回到banner信息，(port, banner)
        @type port_info: tuple
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        port_results = []
        probe_infos = [port_info[0]]
        all_probes = self.serviceProbe.allprobes
        match_result = self.match_all_probes(host, port_info, all_probes, progress)
        if match_result[0] == 'Unknown':  # 如果默认TCP协议探测失败 再尝试使用UDP协议探测
            progress.print(formatString(f"使用TCP协议探测主机 {host}:{port_info[0]} 服务失败, 正在尝试UDP.",
                                        level="DEBUG", space=11, gap=8))
            udp_match_result = self.match_all_probes(host, port_info, all_probes, progress, protocol="UDP")
            if udp_match_result[0] != "Unknown":
                match_result[0] = udp_match_result[0]
                match_result[1] = udp_match_result[1]
        probe_infos.extend(match_result)
        port_results.append(tuple(probe_infos))

        # 每探测一个端口便更新一次服务识别进度条
        for task in progress.tasks:
            if "服务识别" in task.description and not self.noProbe:
                progress.update(task.id, advance=1)
        return port_results

    def match_all_probes(self, host, port_info, all_probes, progress, protocol="TCP"):
        """
        匹配所有探针

        @param host: 主机地址
        @type host: str
        @param port_info: 含端口号或者端口返回到banner信息，(port, banner)
        @type port_info: tuple
        @param all_probes: 所有的 nmap-service-probes
        @type all_probes: list
        @param progress: 进度条对象
        @type progress: Progress
        @param protocol: 探测协议 可选TCP或者UDP
        @type protocol: str
        @return:
        @rtype:
        """
        nmap_fingerprint = {}
        in_probes, ex_probes = self.serviceProbe.filter_probes_by_port(port_info[0], all_probes)
        if in_probes:
            progress.print(formatString(f"正在匹配包含 {port_info[0]} 端口的探针, 共 {len(in_probes)} 个.",
                                        level="INFO", space=11, gap=9))
            probes = self.serviceProbe.sort_probes_by_rarity(in_probes)
            nmap_fingerprint = self.async_match_all_probes(
                host, port_info, protocol, probes, progress
            )
        if "match" in nmap_fingerprint:
            return fingerprint2list(nmap_fingerprint, progress)
        if ex_probes and (self.excludeProbe or port_info[1]):
            progress.print(formatString(f"正在匹配不包含 {port_info[0]} 端口的探针, 共 {len(ex_probes)} 个.",
                                        level="INFO", space=11, gap=9))
            ex_nmap_fingerprint = self.async_match_all_probes(
                host, port_info, protocol, ex_probes, progress, True if in_probes else False
            )
            nmap_fingerprint.update(ex_nmap_fingerprint)
        return fingerprint2list(nmap_fingerprint, progress)

    def async_match_all_probes(self, host, port_info, protocol, probes, progress, noweb=False):
        """
        协程并发探测端口服务

        @param host: 主机地址
        @type host: str
        @param port_info: 含端口号或者端口返回到banner信息，(port, banner)
        @type port_info: tuple
        @param protocol: 探测协议
        @type protocol: str
        @param probes: 需要探测的探针
        @type probes: list
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        @param noweb: 不进行web指纹匹配
        @type noweb: boolean
        """
        nmap_fingerprint = {}
        result_set = []
        loop = None
        try:
            loop = asyncio.get_event_loop()
        except RuntimeError as e:
            if "There is no current event loop in thread" in str(e):
                loop = asyncio.new_event_loop()
        # 修复windows报Event loop is closed的问题
        py_ver = int(f"{sys.version_info.major}{sys.version_info.minor}")
        if py_ver > 37 and sys.platform.startswith('win'):
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        asyncio.set_event_loop(loop)
        if not self.nosrv:
            loop.run_until_complete(self.scan_with_probes(host,
                                                          port_info,
                                                          protocol,
                                                          probes,
                                                          progress,
                                                          result_set))
            if result_set:
                for match in result_set:
                    if "match" in match and bool(match["match"]["versioninfo"]) and (
                            match["match"]["versioninfo"]["version"]
                            or match["match"]["versioninfo"]["vendorproductname"]
                            or match["match"]["versioninfo"]["operatingsystem"]
                            or match["match"]["versioninfo"]["cpename"]
                            or match["match"]["versioninfo"]["info"]):
                        if not match["match"]["versioninfo"]["vendorproductname"]:
                            match["match"]["versioninfo"]["vendorproductname"] = [match["probe"]["probename"]]
                        nmap_fingerprint = match
                        progress.print(formatString(f"识别到主机 {host}:{port_info[0]}服务: {match['match']['versioninfo']}",
                                                    level="INFO", space=11, gap=9))
                        break
        else:
            progress.print(formatString(f"[bold yellow]未启用服务探测, 已忽略主机 [/bold yellow]{host}:{port_info[0]}.",
                                        level="INFO", space=11, gap=9))
        if (is_http_match(result_set) or is_http_port(port_info)) \
                and not self.noweb \
                and (protocol == "TCP" and not noweb):
            web_result = loop.run_until_complete(self.scan_with_webfps(host, port_info, progress))
            nmap_fingerprint.update({"web_matches": web_result})
        return nmap_fingerprint

    async def scan_with_probes(self, host, port_info, protocol, probes, progress, result_set):
        """
        并发探测

        @param host: 主机地址
        @type host: str
        @param port_info: 含端口号或者端口返回到banner信息，(port, banner)
        @type port_info: tuple
        @param protocol: 探测协议
        @type protocol: str
        @param probes: 需要探测的探针
        @type probes: list
        @param progress: 进度条对象
        @type progress: Progress
        @param result_set: list
        @type result_set: 探测结果集
        @return:
        @rtype:
        """
        sem = asyncio.Semaphore(self.coroutine_number)

        async def aw_task(aw):
            async with sem:
                return await aw

        task_list = []

        for probe in probes:
            record = self.send_payload_or_match_request(
                host, port_info, protocol, probe, self.timeout, progress, result_set
            )
            if sys.version_info < (3, 7):
                task = asyncio.ensure_future(aw_task(record))
            else:
                task = asyncio.create_task(aw_task(record))
            task_list.append(task)
        await asyncio.gather(*task_list)

    async def scan_with_webfps(self, host, port_info, progress):
        """
        探测WEB指纹信息

        @param host: 主机地址
        @type host: str
        @param port_info: 端口信息
        @type port_info: tuple
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        fp_matches = exploit = ''
        fp_message = ''
        response, url = await self.async_get_response(host, port_info[0], progress)
        progress.print(formatString(f"正在探测主机 {host}:{port_info[0]} WEB服务.", level="INFO", space=11, gap=9))
        if response and url:
            if not self.nofp:
                progress.print(
                    formatString(f"获取到主机 {host}:{port_info[0]} 响应: {response.status_code}, 正在进行WEB指纹探测.",
                                 level="INFO",
                                 space=11, gap=9))
                self.superscan.asyncRequest.set_progress(progress)
                try:
                    fingerprint = await self.superscan.asyncFpMatches(response,
                                                                      host=url,
                                                                      progress=progress,
                                                                      mode=self.fpmode,
                                                                      fp_filter=self.fingerprint_filter)
                except Exception as e:
                    fingerprint = None
                    # exc_type, exc_value, exc_traceback = sys.exc_info()
                    # progress.print(f"exception on scan_with_webfps: {repr(e)}, {traceback.format_tb(exc_traceback)}")
                if fingerprint:
                    exploit = is_exploit_match(fingerprint)
                    if exploit:
                        exploit = format_exploit(exploit)
                fp_matches = format_fp_matches(fingerprint, self.web_mini_percent)
                if fingerprint and not self.nofp:
                    fp_message = f"识别到指纹信息: {fingerprint}"
        progress.print(formatString(f"探测主机 {host}:{port_info[0]} WEB服务完成! {fp_message}", level="INFO", space=11, gap=9))
        return response, fp_matches, exploit

    async def async_get_response(self, host, port, progress):
        """
        根据端口尝试获取HTTP响应

        @param host: 主机地址
        @type host: str
        @param port: 端口号
        @type port: int
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        request = Request.instance(env.CliOptions, isSync=True)
        request.set_progress(progress)
        request.retries = 2
        self.superscan.asyncRequest.set_progress(progress)
        try:
            if is_https_port(port):
                url = f"https://{host}:{port}"
                response = await request.get(url)
                if response:
                    return response, url
            url = f"http://{host}:{port}"
            response = await request.get(url)
            if not response:
                url = f"https://{host}:{port}"
                response = await request.get(url)
                return response, url
        except Exception as e:
            response = ''
            url = ''
            progress.print(repr(e))
        finally:
            await request.aclose()
        return response, url

    async def send_payload_or_match_request(self, host, port_info, protocol, probe, timeout, progress, result_set):
        """
        主动发送探针Payload及匹配banner信息

        @param host: 主机地址
        @param port_info: 含端口号或者端口返回到banner信息，(port, banner)
        @type port_info: tuple
        @param protocol: 探测协议
        @type protocol: str
        @param probe: 需要探测的探针
        @type probe: list
        @param timeout: 连接超时
        @type timeout: int
        @param progress: 进度条对象
        @type progress: Progress
        @param result_set: 结果集合
        @type result_set: list
        @return:
        @rtype:
        """
        proto = probe['probe']['protocol']
        payload = probe['probe']['probestring']
        payload, _ = codecs.escape_decode(payload)
        if 'totalwaitms' in probe:
            timeout = int(int(probe['totalwaitms']['totalwaitms']) / 1000)
        port, response = port_info
        match_http = False
        if response or response == '':
            response = base64.b64decode(response)
        if not response and (proto.upper() == protocol.upper()):
            if not self.usescf:
                response = await self.send_request(host, port, protocol.upper(), payload, timeout, progress)
            else:
                scf_result = await self.send_request_scf(host, port, progress, proto.upper(), payload, timeout)
                if scf_result and "connected" in scf_result and scf_result["connected"]:
                    response = base64.b64decode(scf_result["body"])
            # progress.print(formatString(f"正在匹配探针 {probe['probe']['probename']}, 发送Payload 长度: {len(payload)} bytes.",
            #                             level="DEBUG", space=11, gap=8))
        response = response.decode(encoding="utf-8", errors="ignore")
        if re.match(r"^HTTP/", response):  # 匹配是否为HTTP响应
            match_http = True
        nmap_pattern, nmap_fingerprint = await self.match_probe_pattern(response, probe, progress)
        if nmap_fingerprint:
            record = {
                "probe": {
                    "probename": probe["probe"]["probename"],
                    "probestring": probe["probe"]["probestring"]
                },
                "match": {
                    "pattern": nmap_pattern,
                    "versioninfo": nmap_fingerprint
                },
                "match_http": match_http
            }
            result_set.append(record)
        else:
            result_set.append({"match_http": match_http})

    async def send_request_scf(self, host, port, progress, proto, payload, timeout):
        endpoint = build_endpoint(host, port, proto, payload)
        return await self.scf_request(endpoint, progress)

    async def scf_request(self, proxy_endpoint, progress):
        result = {}
        # 这里需要重新实例化AsyncRequest类 不能在子线程中调用父线程中的asyncRequest 否则会出现attached to a different loop错误
        request = Request.instance(env.CliOptions, isSync=True)
        request.set_progress(progress)
        response = await request.get(proxy_endpoint)
        if response and response.status_code == 200:
            try:
                result = json.loads(response.text)
                if "errorCode" in result and "errorMessage" in result:
                    progress.print(formatString(result["errorMessage"], level="WARNING", space=11, gap=6))
            except Exception:
                pass
        return result

    async def send_request(self, host, port, proto, payload, timeout, progress: Progress) -> bytes:
        """
        发送探针Payload

        @param host: 主机地址
        @type host: str
        @param port: 主机端口
        @type port: int
        @param proto: 连接协议
        @type proto: str
        @param payload: 探针Payload
        @type payload: bytes
        @param timeout: 连接超时时间
        @type timeout: int
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        data = b''
        try:
            fut = asyncio.open_connection(host, port, proto=socket.getprotobyname(proto))
            connect_result = await asyncio.wait_for(fut, timeout=timeout)
            if connect_result:
                reader, writer = connect_result
                writer.write(payload)
                try:
                    while True:
                        _ = await asyncio.wait_for(reader.read(1024), timeout=10)
                        if not _:
                            break
                        data += _
                except Exception as e:
                    pass
                finally:
                    writer.close()
                    await writer.wait_closed()
        except Exception as e:
            pass
        return data

    async def match_probe_pattern(self, data, probe, progress: Progress):
        """
        正则匹配探针的所有匹配项

        @param data: 端口返回数据
        @type data: str
        @param probe: 探针信息
        @type probe: list
        @param progress: 进度条对象
        @type progress: Progress
        @return:
        @rtype:
        """
        nmap_pattern, nmap_fingerprint = "", {}

        if not data:
            return nmap_pattern, nmap_fingerprint

        try:
            matches = probe['matches']

            for match in matches:
                pattern = match['pattern']
                pattern_compiled = match['pattern_compiled']
                service = match['service']

                # https://github.com/nmap/nmap/blob/master/service_scan.cc#L476
                # regex = re.compile(pattern, re.IGNORECASE | re.DOTALL)

                rfind = pattern_compiled.findall(data)

                if rfind and ("versioninfo" in match):
                    versioninfo = match['versioninfo']

                    rfind = rfind[0]
                    rfind = [rfind] if isinstance(rfind, str) else rfind

                    # (['5.5.38-log'], <type 'list'>)
                    # ([('2.0', '5.3')], <type 'list'>)
                    # ([('2.4.7', 'www.nongnu.org')], <type 'list'>)

                    for index, value in enumerate(rfind):
                        dollar_name = "${}".format(index + 1)

                        versioninfo = versioninfo.replace(dollar_name, value)

                    nmap_pattern = pattern
                    nmap_fingerprint = await self.match_versioninfo(versioninfo)
                    break
        except Exception as err:
            progress.print(f"服务指纹匹配错误 {repr(err)}")

        return nmap_pattern, nmap_fingerprint

    async def match_versioninfo(self, versioninfo):
        """
        探针版本匹配

        @param versioninfo: 探针版本信息
        @type versioninfo: str
        @return:
        @rtype:
        """
        # p/vendorproductname/
        # v/version/
        # i/info/
        # h/hostname/
        # o/operatingsystem/
        # d/devicetype/
        # cpe:/cpename/[a]

        # p/SimpleHTTPServer/ v/0.6/ i/Python 3.6.0/ cpe:/a:python:python:3.6.0/ cpe:/a:python:simplehttpserver:0.6/
        # p/Postfix smtpd/ cpe:/a:postfix:postfix/a
        # s
        # s p/TLSv1/
        # p/Postfix smtpd/ cpe:/a:postfix:postfix/a

        record = {
            "vendorproductname": [],
            "version": [],
            "info": [],
            "hostname": [],
            "operatingsystem": [],
            "cpename": []
        }

        if " p/" in versioninfo or " p|" in versioninfo:
            # regex = re.compile(r"p/([^/]*)/")
            exclude_char = re.search(" p([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: p[/|\\|]+)([^{exclude_char}]*)[/|\\|]+")
            vendorproductname = regex.findall(versioninfo)
            record["vendorproductname"] = vendorproductname

        if " v/" in versioninfo or " v|" in versioninfo:
            # regex = re.compile(r"v/([^/]*)/")
            exclude_char = re.search(" v([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: v[/|\\|]+)([^{exclude_char}]*)[/|\\|]+")
            version = regex.findall(versioninfo)
            record["version"] = version

        if " i/" in versioninfo or " i|" in versioninfo:
            # regex = re.compile(r"i/([^/]*)/")
            exclude_char = re.search(" i([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: i[/|\\|]+)([^{exclude_char}]*)[/|\\|]+")
            info = regex.findall(versioninfo)
            record["info"] = info

        if " h/" in versioninfo or " h|" in versioninfo:
            exclude_char = re.search(" h([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: h[/|\\|]+)([^{exclude_char}]*)[/|\\|]+")
            hostname = regex.findall(versioninfo)
            record["hostname"] = hostname

        if " o/" in versioninfo or " o|" in versioninfo:
            exclude_char = re.search(" o([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: o[/|\\|]+)([^{exclude_char}]*)[/|\\|]+")
            operatingsystem = regex.findall(versioninfo)
            record["operatingsystem"] = operatingsystem

        if " d/" in versioninfo or " d|" in versioninfo:
            exclude_char = re.search(" d([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: d[/|\\|]+)([^{exclude_char}]*)[/||\\|]+")
            devicetype = regex.findall(versioninfo)
            record["devicetype"] = devicetype

        if " cpe:/" in versioninfo or " cpe:|" in versioninfo:
            exclude_char = re.search(" cpe:([/|\\|]+)", versioninfo).group(1)
            regex = re.compile(rf"(?: cpe:[/|\\|]+)a:([^{exclude_char}]*)[/|\\|]+")
            cpename = regex.findall(versioninfo)
            record["cpename"] = cpename

        return record

    class MyThread(threading.Thread):
        def __init__(self, thread_id, thread_name, work_queue, called_fun, progress: Progress, **kwargs):
            super().__init__()
            self.threadID = thread_id
            self.name = thread_name
            self.workQueue = work_queue
            self.called_fun = called_fun
            self.progress = progress
            self.kwargs = kwargs

        def run(self) -> None:
            self.called_fun(self.name, self.workQueue, self.progress, **self.kwargs)

    async def is_host_alive(self, host: ipaddress.IPv4Network, sock: socket.socket, progress: Progress, result):
        """
        验证主机是否存活

        @param host: 主机地址
        @type host: ipaddress.IPv4Network
        @param sock: socket 对象
        @type sock: socket
        @param progress: 进度条对象
        @type progress: Progress
        @param result: 存活主机结果列表
        @type result: list
        @return: 主机是否存活
        @rtype: boolean
        """
        pkt_id = os.getpid() & 0xFFFF
        package = ICMP(id=pkt_id)
        un_pkt_id = struct.unpack("H", struct.pack("!H", pkt_id))[0]
        # if self.usescf:  # 如果开启云函数功能则使用云函数代理请求
        #     return await self.ping_host_scf(host, sock, package, un_pkt_id, result, progress)
        return await exec_sync_fun(self.ping_host, args=(host, sock, progress, result, package, un_pkt_id))

    def ping_host(self, host, sock: socket.socket, progress: Progress, result, package, un_pkt_id):
        """
        发送icmp数据包探测主机是否存活

        @param host: 探测主机
        @param sock: socket对象
        @param progress: 进度条对象
        @param result: 存储存活主机列表
        @param package: ICMP数据包
        @param un_pkt_id: 数据包id
        @return:
        """
        is_alive = False
        rev, address = send_package(str(host), sock, raw(package))
        if rev and address:
            icmp_header = rev[20:28]
            icmp_type, icmp_code, icmp_checksum, packet_id, seq = struct.unpack("bbHHh", icmp_header)
            is_alive = (icmp_type == 0 and packet_id == un_pkt_id)
            if is_alive:
                self.queueLock.acquire()
                result.append(address[0])
                self.workQueue.put(address[0])
                progress.print(formatString(
                    f"Host {address[0]} is alive!",
                    level="INFO", space=11, gap=9))
                self.queueLock.release()
        # 更新存活主机探测进度条
        for task in progress.tasks:
            if "存活探测" in task.description:
                progress.update(task.id, advance=1)
        return is_alive

    async def ping_host_scf(self, host: ipaddress.IPv4Network, sock, package, un_pkt_id, result, progress: Progress):
        pass

    def get_socket(self, family=socket.AF_INET, socket_type=socket.SOCK_RAW, proto=0,
                   fileno=None, progress=None) -> socket.socket:
        """
        创建socket对象

        @param family:
        @param socket_type:
        @param proto:
        @param fileno:
        @param progress:
        @type progress:
        @return:
        """
        try:
            sock = socket.socket(family=family, type=socket_type, proto=proto, fileno=fileno)
            sock.settimeout(self.timeout)
        except PermissionError as e:
            if progress:
                progress.print(formatString("[bold red]当前用户无权使用socket, 请使用管理权限运行模块或使用"
                                            " [bold green]--noping[/bold green] 参数扫描![/bold red]",
                                            level="ERROR", space=11, gap=8))
            raise ExploitValidationException("[bold red]当前用户无权使用socket, 请使用管理权限运行模块或使用"
                                             " [bold green]--noping[/bold green] 参数扫描![/bold red]")
        return sock

    def start_chk_alive_hosts(self, progress):
        """
        启动存活主机探测线程 实现边检测边扫描

        @param progress:
        @return: 事件循环对象
        """
        coroutine = self.async_chk_alive_hosts(self.hosts, progress)
        ping_loop = asyncio.new_event_loop()
        ping_thread = threading.Thread(target=start_loop, args=(ping_loop,))
        ping_thread.start()

        asyncio.run_coroutine_threadsafe(coroutine, ping_loop)
        return ping_loop

    async def async_chk_alive_hosts(self, hosts, progress):
        """
        多线程验证存活主机

        @param hosts: 需要检查到主机列表
        @type hosts: list
        @param progress: 进度条对象
        @type progress: Progress
        @return: 存活主机列表
        @rtype: list
        """
        # 修复windows报Event loop is closed的问题
        py_ver = int(f"{sys.version_info.major}{sys.version_info.minor}")
        if py_ver > 37 and sys.platform.startswith('win'):
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

        sem = asyncio.Semaphore(env.CliOptions.thread)

        async def aw_task(aw):
            async with sem:
                return await aw

        tasklist = []
        result = []
        sock = self.get_socket(proto=socket.getprotobyname('icmp'), progress=progress)
        for host in hosts:
            is_alive = self.is_host_alive(host, sock, progress, result)
            if sys.version_info < (3, 7):
                task = asyncio.ensure_future(aw_task(is_alive))
            else:
                task = asyncio.create_task(aw_task(is_alive))
            tasklist.append(task)
        await asyncio.gather(*tasklist)

        sock.close()
        self.hosts = result
        return result
